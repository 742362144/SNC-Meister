// SNC-MeisterClient.cpp - SNC-Meister admission control client.
// Communicates with SNC-Meister admission control server to add tenants (a.k.a. clients).
// If the -g option is specified, all tenants in the config file are admitted/rejected as a group.
// Otherwise, each tenant is admitted/rejected one-by-one.
// The config file is in the same format as for SNC-Calculator and can be generated by SNC-ConfigGen.
//
// Copyright (c) 2016 Timothy Zhu.
// Licensed under the MIT License. See LICENSE file for details.
//

#include <iostream>
#include <fstream>
#include <string>
#include <ctime>
#include <cstdlib>
#include <unistd.h>
#include <rpc/rpc.h>
#include "../prot/SNC_Meister_prot.h"
#include "../json/json.h"

using namespace std;

Json::Value rootConfig;

// Print the current date/time.
void printTime()
{
    time_t t;
    time(&t);
    cout << ctime(&t);
}

// Read config file
bool readConfig(char* configFilename)
{
    // Open config file
    ifstream inputFile(configFilename);
    if (!inputFile.good()) {
        cerr << "Failed to read config file " << configFilename << endl;
        return false;
    }
    // Parse file
    Json::Reader reader;
    if (!reader.parse(inputFile, rootConfig)) {
        cerr << "Failed to parse config file " << configFilename << endl;
        return false;
    }
    return true;
}

// Write config file
bool writeConfig()
{
    // Open output file
    ofstream outputFile(rootConfig["outputConfig"].asCString());
    if (!outputFile.good()) {
        cerr << "Failed to open output file " << rootConfig["outputConfig"].asString() << endl;
        return false;
    }
    // Output config file with admitted clients
    Json::StyledStreamWriter writer;
    writer.write(outputFile, rootConfig);
    return true;
}

// Add queues to SNC-Meister
void addQueues(const Json::Value& queueInfos, CLIENT* cl)
{
    for (unsigned int queueInfoIndex = 0; queueInfoIndex < queueInfos.size(); queueInfoIndex++) {
        const Json::Value& queueInfo = queueInfos[queueInfoIndex];
        SNCAddQueueArgs args;
        Json::StyledWriter writer;
        string queueInfoStr = writer.write(queueInfo);
        args.queueInfo = new char[queueInfoStr.length() + 1];
        strcpy(args.queueInfo, queueInfoStr.c_str());
        if (snc_meister_add_queue_1(args, cl) == NULL) {
            clnt_perror(cl, "Failed network RPC");
        }
        delete args.queueInfo;
    }
}

// Try to admit a new set of clients
bool addClients(const Json::Value& clientInfos, CLIENT* cl)
{
    bool admitted = false;
    // Build RPC parameters
    SNCAddClientsArgs args;
    Json::StyledWriter writer;
    string clientInfosStr = writer.write(clientInfos);
    args.clientInfos = new char[clientInfosStr.length() + 1];
    strcpy(args.clientInfos, clientInfosStr.c_str());
    SNCAddClientsRes* result;
    result = snc_meister_add_clients_1(args, cl);
    if (result == NULL) {
        writeConfig();
        clnt_perror(cl, "Failed network RPC");
        exit(-1);
    } else {
        if (result->status == SNC_SUCCESS) {
            admitted = result->admitted;
        } else {
            cerr << "AddClients failed with status " << result->status << endl;
            writeConfig();
            exit(-1);
        }
    }
    delete args.clientInfos;
    return admitted;
}

// SIGTERM/SIGINT signal for cleanup
void term_signal(int signum)
{
    writeConfig();
    exit(0);
}

int main(int argc, char** argv)
{
    int opt = 0;
    char* configFilename = NULL;
    char* serverAddr = NULL;
    bool groupAdmit = false;
    do {
        opt = getopt(argc, argv, "c:s:g");
        switch (opt) {
            case 'c':
                configFilename = optarg;
                break;

            case 's':
                serverAddr = optarg;
                break;

            case 'g':
                groupAdmit = true;
                break;

            case -1:
                break;

            default:
                break;
        }
    } while (opt != -1);

    if ((configFilename == NULL) || (serverAddr == NULL)) {
        cout << "Usage: " << argv[0] << " -c configFilename -s serverAddr [-g]" << endl;
        return -1;
    }

    printTime();

    // Read config
    if (!readConfig(configFilename)) {
        return -1;
    }
    // Setup signal handler
    struct sigaction action;
    action.sa_handler = term_signal;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    sigaction(SIGTERM, &action, NULL);
    sigaction(SIGINT, &action, NULL);
    // Connect to SNC-Meister server
    CLIENT* cl = clnt_create(serverAddr, SNC_MEISTER_PROGRAM, SNC_MEISTER_V1, "tcp");
    if (cl == NULL) {
        clnt_pcreateerror(serverAddr);
        return -1;
    }
    // Set nearly infinite RPC timeout
    struct timeval timeout;
    timeout.tv_sec = 36000;
    timeout.tv_usec = 0;
    clnt_control(cl, CLSET_TIMEOUT, reinterpret_cast<char*>(&timeout));
    // Add queues
    addQueues(rootConfig["queues"], cl);
    // Add clients
    Json::Value& clientInfos = rootConfig["clients"];
    if (groupAdmit) {
        bool admitted = addClients(clientInfos, cl);
        if (admitted) {
            cout << "Admitted" << endl;
        } else {
            cout << "Rejected" << endl;
        }
    } else {
        for (unsigned int clientInfoIndex = 0; clientInfoIndex < clientInfos.size();) {
            Json::Value& clientInfo = clientInfos[clientInfoIndex];
            Json::Value singleClientInfos = Json::arrayValue;
            singleClientInfos.append(clientInfo);
            printTime();
            bool admitted = addClients(singleClientInfos, cl);
            if (admitted) {
                cout << "Admitted " << clientInfo["name"].asString() << endl;
                clientInfoIndex++;
            } else {
                cout << "Rejected " << clientInfo["name"].asString() << endl;
                Json::Value removed;
                if (!clientInfos.removeIndex(clientInfoIndex, &removed)) {
                    cerr << "Failed to remove JSON clientInfo" << endl;
                    // Destroy client
                    clnt_destroy(cl);
                    return -1;
                }
            }
        }
        // Write config
        if (!writeConfig()) {
            // Destroy client
            clnt_destroy(cl);
            return -1;
        }
    }
    // Destroy client
    clnt_destroy(cl);

    printTime();
    return 0;
}
